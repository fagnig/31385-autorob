<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>31385 - Autonomous Robots</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <h3 id="31385---autonomous-robots">31385 - Autonomous Robots</h3>
<h3 id="team-20">Team 20</h3>
<h3 id="s175210---peter-t%c3%b8nder-blendstrup">s175210 - Peter Tønder Blendstrup</h3>
<h3 id="s191731---jeremy-paul-coffelt">s191731 - Jeremy Paul Coffelt</h3>
<h3 id="s175179---joachim-sch%c3%b8ndorff-mortensen">s175179 - Joachim Schøndorff Mortensen</h3>
<p>Graphs and matlab files found at <a href="https://github.com/fagnig/31385-autorob/tree/master/sim/ex">https://github.com/fagnig/31385-autorob/tree/master/sim/ex</a></p>
<h1 id="day-1">Day 1</h1>
<h2 id="ex1-351">Ex1 3.5.1</h2>
<p>Robot moves approx. 1.5m forward (errors of 0.002m's)</p>
<h2 id="ex1-352">Ex1 3.5.2</h2>
<p>Robot moves approx. in a rectangle, with slight errors (Seems to not turn far enough)</p>
<h2 id="ex1-353">Ex1 3.5.3</h2>
<p>Robot moves in a fluid motion.</p>
<h2 id="ex1-354">Ex1 3.5.4</h2>
<p>Robot follows straight black line as expected</p>
<h2 id="ex1-355">Ex1 3.5.5</h2>
<p>Robot follows right branch and passes the fork without a hitch.
Robot is slightly offset to the left, since it uses its right sensors to follow the line.</p>
<h2 id="ex1-356">Ex1 3.5.6</h2>
<p>Robot moves along the left branch, ignores the perpendicular black line.
Robot seems slightly offset to the right, probably since it uses its left sensors to follow the line</p>
<h2 id="ex1-357">Ex1 3.5.7</h2>
<p>Same as above, except the robot stops at the perpendicular black line</p>
<h2 id="ex1-358">Ex1 3.5.8</h2>
<p>Robot follows straight line until it comes within 0.4m's of obstacle and stops.</p>
<h2 id="ex2-31">Ex2 3.1</h2>
<p>Formulas are implemented in MatLab and give expected results</p>
<p>Matlab file: (robot_calibrator.m)</p>
<h2 id="ex2-32">Ex2 3.2</h2>
<p>Simulation was run, and large errors observed.
These were used in our MatLab script, and Ed &amp; Eb values were found. (Eb = ; Ed = )
Odometry was updated with zeroed coordinates, and got the following values: (0.26; 1, 0.0002~ )
We used these values and our Eb to recalibrate the real width between the wheels.
After second execution of the simulation the square was much neater.
Recalibration with the odometry-update function gave the same calibration data.</p>
<h1 id="day-2">Day 2</h1>
<h2 id="ex4-2">Ex4 2</h2>
<p>Square program was run, turning around one wheel observed
Square program modified, robot now turns around center point
This was achieved by averaging out the positions of the wheels, rather than using one wheel as the starting point.</p>
<h2 id="ex4-31">Ex4 3.1</h2>
<p>Square program was modified to include logging
This was done by having a staticly allocated array of &quot;logentry&quot; structs that is added once per loop-iteration.
The array is output to &quot;output.dat&quot; after the state ms_end is reached</p>
<p>Matlab file: (ex_3_1.m)</p>
<h2 id="ex4-32">Ex4 3.2</h2>
<p>Odometry implemeted by finding x, y and theta every time update_odo is called.
Formulas from &quot;Where Am I?&quot; p.20.
Logging now prints the new values as well as the values from 3.1.</p>
<p>Matlab file: (ex_3_2.m)</p>
<h2 id="ex4-33">Ex4 3.3</h2>
<p>Speed limit of about 0.4~0.5 observed.</p>
<p>Matlab file: (ex_3_3.m)</p>
<h2 id="ex4-34">Ex4 3.4</h2>
<p>Acceleration limit implemented, tested for 0.2, 0.4, 0.6 m/s.
Anomaly observed, slope never ends up as steep as the original when slowly stepping up the speed. TA asked.</p>
<p>Matlab file: (ex_3_4.m)</p>
<h2 id="ex4-35">Ex4 3.5</h2>
<p>Decceleration limit implemented tested for 0.2, 0.4, 0.6 m/s.
Nice slowdown observed at the end of the robot movement.</p>
<p>Matlab file: (ex_3_5.m)</p>
<h2 id="ex4-36">Ex4 3.6</h2>
<p>Both speed limits are now applied to turning</p>
<h2 id="ex3-21">Ex3 2.1</h2>
<p>Test scripts executed as expected on the robot
Followed line with minor issues, slight wobbling.</p>
<h2 id="ex3-22">Ex3 2.2</h2>
<p>Odometry calibration succeeded after changing robots twice.
The first two were uncalibrateable in the selected area because they got so off-course they left the area and would have hit the walls.</p>
<h2 id="ex3-23">Ex3 2.3</h2>
<p>Both the clockwise and counterclockwise square runs ended up completing with errors of less than 4cm.</p>
<h1 id="day-3">Day 3</h1>
<h2 id="ex5-squareprog">Ex5 Squareprog</h2>
<p>Square program completed in both turning directions, with negligible errors, as above.</p>
<h2 id="ex5-zoneobst">Ex5 Zoneobst</h2>
<p>Calling zoneobst output 9 zone distance values as expected</p>
<h2 id="ex5-zoneobst-with-mrc">Ex5 Zoneobst with MRC</h2>
<p>A script was made, logging $l0..8
Without a &quot;wait&quot; command it logs a handful of times before stopping
With &quot;wait 1&quot; it logs approx 100 times</p>
<h2 id="ex5-zoneobst-with-square">Ex5 Zoneobst with square</h2>
<p>Square program was changed to save laser-server data to the output file.
Inspecting the output file, many datapoints are logged, in a format similar to the zoneobst command.</p>
<h1 id="day-4">Day 4</h1>
<h2 id="ex6-21">Ex6 2.1</h2>
<p>SMRCL script was made to make 100 measurements, move forward 30cm and then make 100 more measurements.
Matlab script that is able to generate the linear calibration transformation was written.
First tested with simulator, then later with the actual SMR robot.</p>
<p>SMRCL script: (ex_6_2_1) / Matlab script: (linesensor_converter.m)</p>
<h2 id="ex6-22">Ex6 2.2</h2>
<p>SMRCL script was made to make 100 measurements, and step forward in 10cm increments and taking 100 more measurements.
Matlab script that is able to approximate Ka &amp; Kb from measured values and fit a function.
Thus far only run on measurements from the simulator.</p>
<p>SMRCL script: (ex_6_2_2) / Matlab script: (irdist.m)</p>
<h1 id="day-5">Day 5</h1>
<h2 id="ex7-2">Ex7 2</h2>
<p>An angular controller was implemented, first with a K value of 10, leading to a far too fast acceleration.
The K was subsequently changed to 0.1, leading to a much smoother speed-up.
Plotting the x and y, the x and y displacement from 0 fluctuated to a maximum of 0.1 mm over the duration.
Plotting theta we saw a smooth increase in the angle, with curves at the beginning at the end, due to the implementation of acceleration and deceleration.</p>
<h2 id="ex7-31">Ex7 3.1</h2>
<p>Very simple normalising function was implemened: val*factor+offset
This normalises the sensor value based upon the calibration values</p>
<h2 id="ex7-32">Ex7 3.2</h2>
<p>Simply looping through the normalised sensor values and finding the lowest value, and returning the found values index.
This was expanded to also be able to find the highest value index, for finding a white line.
A function to determine if there was a line at all was also implemented.</p>
<h2 id="ex7-33">Ex7 3.3</h2>
<p>Implementing the simple line following algorithm using the DeltaV = K * (DeltaLs).
K was, through imperical testing, decided to be 0.005.
This line following was very rough, as the lowest sensor value will regularly change between the two middle sensors when driving straight.</p>
<h2 id="ex7-34">Ex7 3.4</h2>
<p>The center of gravity algorithm was implemented directly.
x = {-7, -5 ... 5, 7}     positions of sensors on a line segment, offset from the center of the robot
I = normalised sensor measurements</p>
<h2 id="ex7-35">Ex7 3.5</h2>
<p>The output of the above function was used instead of the lookup value from the above x-table.
K = 0.01 since the center of gravity algorithm gives a finer granularity, meaning we need to steer more aggressively.
Robot followed line in all test cases.</p>

    </body>
    </html>